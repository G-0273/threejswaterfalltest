<script>
document.addEventListener("DOMContentLoaded", async () => {
  const mindarThree = new window.MINDAR.IMAGE.MindARThree({
    container: document.querySelector("#container"),
    imageTargetSrc: "./green.mind",
    filterMinCF: 0.1,
    filterBeta: 0.01,
  });

  const { renderer, scene, camera } = mindarThree;
  camera.position.z = 3;

  const anchors = [mindarThree.addAnchor(0), mindarThree.addAnchor(1), mindarThree.addAnchor(2)];

  const gltfLoader = new THREE.GLTFLoader();
  let model;
  let mixer;
  let persisted = false;
  let animations;

  gltfLoader.load("models/waterfall.glb", (gltf) => {
    model = gltf.scene;
    animations = gltf.animations;

    model.scale.set(0.3, 0.3, 0.3);
    model.rotation.set(0, -Math.PI / 2, 0);
    model.position.set(0, -1.3, 0);

    anchors.forEach(anchor => anchor.group.add(model.clone()));

    if (animations.length > 0) {
      mixer = new THREE.AnimationMixer(model);
      animations.forEach((clip) => {
        const action = mixer.clipAction(clip);
        action.play();
      });
    }
  });

  anchors.forEach((anchor) => {
    anchor.onTargetFound = () => {
      if (!persisted && model) {
        setTimeout(() => {
          if (!anchor.group.visible) return;

          model.updateMatrixWorld(true);
          const worldPos = new THREE.Vector3();
          const worldQuat = new THREE.Quaternion();
          const worldScale = new THREE.Vector3();
          model.matrixWorld.decompose(worldPos, worldQuat, worldScale);

          anchor.group.remove(model);
          model.position.copy(worldPos);
          model.quaternion.copy(worldQuat);
          model.scale.copy(worldScale);
          scene.add(model);

          // Reassign mixer after detaching
          if (animations.length > 0) {
            mixer = new THREE.AnimationMixer(model);
            animations.forEach((clip) => {
              const action = mixer.clipAction(clip);
              action.play();
            });
          }

          persisted = true;
        }, 300); // small delay to ensure stable position
      }
    };
  });

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(1, 2, 3);
  scene.add(directionalLight);

  await mindarThree.start();

  const clock = new THREE.Clock();
  renderer.setAnimationLoop(() => {
    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);
    renderer.render(scene, camera);
  });
});
</script>

